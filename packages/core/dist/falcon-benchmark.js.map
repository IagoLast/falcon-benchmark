{"version":3,"sources":["webpack://FalconBenchmark/webpack/universalModuleDefinition","webpack://FalconBenchmark/webpack/bootstrap","webpack://FalconBenchmark/./lib/FalconRunner.js","webpack://FalconBenchmark/./lib/events.js","webpack://FalconBenchmark/./lib/index.js","webpack://FalconBenchmark/./lib/profiler.service.js","webpack://FalconBenchmark/./lib/utils.service.js","webpack://FalconBenchmark/./node_modules/mitt/dist/mitt.es.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,kCAAkC;AAClC,sBAAsB,oCAAoC;AAC1D;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC,sBAAsB,mCAAmC;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,yFAAgD,eAAe;AAC/D,OAAO;AACP,2FAAkD,eAAe;AACjE;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,2CAA2C;AAC3C;AACA;AACA,aAAa,cAAc;AAC3B;;AAEA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,KAAK;AACL,cAAc,SAAS,6CAA6C;AACpE;AACA;AACA;AACA;;AAEA,6E;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA,G;;;;;;;;;;;ACLA,iG;;;;;;;;;;;;;;;;ACAA;AACA;;;AAGA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,cAAc;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,G;;;;;;;;;;;;AC7DA;AAAA;AACA;AACA,CAAC;AACD,SAAS,cAAc,iCAAiC;AACxD;;AAEA,gEAAgB,gB;;;;;;;;;;;;ACNhB;AAAA;AACA;AACA;;;;AAIA;;;AAGA;;;;;;AAMA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB;AACA;AACA;AACA,qDAAqD,cAAc,EAAE;AACrE,oDAAoD,oBAAoB,EAAE;AAC1E;AACA;AACA;;AAEA;AACA","file":"falcon-benchmark.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FalconBenchmark\"] = factory();\n\telse\n\t\troot[\"FalconBenchmark\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/index.js\");\n","import mitt from 'mitt';\nimport profiler from './profiler.service';\nimport EVENTS from './events';\n\nexport class FalconRunner {\n  constructor() {\n    this._emitter = mitt();\n    this._tests = [];\n  }\n\n  /**\n * \n * @param {string} event \n * @param {function} callback \n */\n  on(event, callback) {\n    return this._emitter.on(event, callback);\n  }\n\n  /**\n   * \n   * @param {string} event \n   * @param {function} callback \n   */\n  off(event, callback) {\n    return this._emitter.off(event, callback);\n  }\n\n  /**\n   * Get the count of this._tests in the suite\n   */\n  getNumberOfTests() {\n    return this._tests.length;\n  }\n\n  /**\n   * Add a test to the test list.\n   * \n   * @param {string} name - Name of the benchmark\n   * @param {function} fn - Function to benchmark\n   * @param {object} options \n   * @param {number} options.runs - Number of cycles to execute the funcion \n   */\n  benchmark(name, fn, options = {}) {\n    this._tests.push({ name, fn, options, skipped: false });\n  }\n\n  /**\n   * Add a test that wont be executed to the test list\n   */\n  xbenchmark(name, fn, options = {}) {\n    this._tests.push({ name, fn, options, skipped: true });\n  }\n\n  /**\n   * Run all the specs\n   */\n  async run() {\n    const results = [];\n    while (this._tests.length) {\n      const test = this._tests.shift();\n      const result = test.skipped ? {} : await this.runBenchmark(test.name, test.fn, test.options);\n      if (result.error) {\n        this._emitter.emit(EVENTS.TEST_FAILED, { test, result });\n      } else {\n        this._emitter.emit(EVENTS.TEST_COMPLETE, { test, result });\n      }\n      results.push({ test, result });\n    }\n    this._emitter.emit(EVENTS.SUITE_COMPLETE, results);\n  }\n\n  /**\n   * Compute stats about the given function.\n   * \n   * @param {string} name - Name of the benchmark\n   * @param {function} fn - Function to benchmark\n   * @param {object} options \n   * @param {number} options.runs - Number of cycles to execute the funcion \n   */\n  async runBenchmark(name, fn, options = {}) {\n    let result;\n    try {\n      const { runs = 5000 } = options;\n      const executions = [];\n\n      for (let i = 0; i < runs; i++) {\n        const time = await profiler.profile(fn, options);\n        executions.push(time);\n        this._emitter.emit(EVENTS.RUN_COMPLETE);\n      }\n\n      result = profiler.getStats(executions);\n      result.meta = { runs };\n    } catch (error) {\n      return { error: { message: error.message, stack: error.stack } };\n    }\n    return result;\n  }\n}\n\nexport default FalconRunner;","export default {\n  RUN_COMPLETE: 'run-complete',\n  SUITE_COMPLETE: 'suite-complete',\n  TEST_COMPLETE: 'test-complete',\n  TEST_FAILED: 'test-failed'\n};","module.exports = require('./FalconRunner').FalconRunner;","import utils from './utils.service';\nconst performance = utils.performance;\n\n\n/**\n * Computes the time needed to run the function\n * @param {function} fn \n */\nexport async function profile(fn, options) {\n  if (options && options.before) {\n    await options.before.call(this);\n  }\n  const start = performance.now();\n  await fn.call(this);\n  const end = performance.now();\n  if (options && options.after) {\n    await options.after.call(this);\n  }\n  return end - start;\n}\n\n/**\n* Computes statistical parameters from a time array.\n* @param {Array<number>} execution \n*/\nexport function getStats(execution = []) {\n  const total = _sum(execution);\n  const avg = _mean(execution);\n  const variance = _variance(execution, avg);\n  const min = _min(execution);\n  const max = _max(execution);\n  const median = execution.sort()[Math.floor(execution.length / 2)];\n\n  return { avg, median, max, min, variance, total };\n}\n\nfunction _max(array) {\n  return array.reduce((p, n) => p > n ? p : n, Number.NEGATIVE_INFINITY);\n}\n\nfunction _min(array) {\n  return array.reduce((p, n) => p < n ? p : n, Number.POSITIVE_INFINITY);\n}\n\nfunction _variance(array, mean = _mean(array)) {\n  return _mean(array.map(e => Math.pow(e - mean, 2)));\n}\n\nfunction _sum(array) {\n  return array.reduce((p, n) => p + n, 0);\n}\n\nfunction _mean(array) {\n  const sum = _sum(array);\n  return sum / array.length;\n}\n\n\nexport default {\n  getStats,\n  profile\n};","if (typeof window !== 'undefined') {\n    var performance = window.performance;\n} else {\n    var { performance } = eval('require(\"perf_hooks\")'); // eslint-disable-line\n}\n\nexport default { performance };","//      \n// An event handler can take an optional event argument\n// and should not return a value\n                                          \n                                                               \n\n// An array of all currently registered event handlers for a type\n                                            \n                                                            \n// A map of event types and their corresponding event handlers.\n                        \n                                 \n                                   \n  \n\n/** Mitt: Tiny (~200b) functional event emitter / pubsub.\n *  @name mitt\n *  @returns {Mitt}\n */\nfunction mitt(all                 ) {\n\tall = all || Object.create(null);\n\n\treturn {\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to listen for, or `\"*\"` for all events\n\t\t * @param  {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton: function on(type        , handler              ) {\n\t\t\t(all[type] || (all[type] = [])).push(handler);\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to unregister `handler` from, or `\"*\"`\n\t\t * @param  {Function} handler Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff: function off(type        , handler              ) {\n\t\t\tif (all[type]) {\n\t\t\t\tall[type].splice(all[type].indexOf(handler) >>> 0, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `\"*\"` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * @param {String} type  The event type to invoke\n\t\t * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit: function emit(type        , evt     ) {\n\t\t\t(all[type] || []).slice().map(function (handler) { handler(evt); });\n\t\t\t(all['*'] || []).slice().map(function (handler) { handler(type, evt); });\n\t\t}\n\t};\n}\n\nexport default mitt;\n//# sourceMappingURL=mitt.es.js.map\n"],"sourceRoot":""}