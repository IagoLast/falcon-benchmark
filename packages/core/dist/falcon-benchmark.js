!function(n,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.falcon=t():n.falcon=t()}(window,function(){return function(n){var t={};function e(I){if(t[I])return t[I].exports;var g=t[I]={i:I,l:!1,exports:{}};return n[I].call(g.exports,g,g.exports,e),g.l=!0,g.exports}return e.m=n,e.c=t,e.d=function(n,t,I){e.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:I})},e.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e.t=function(n,t){if(1&t&&(n=e(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var I=Object.create(null);if(e.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var g in n)e.d(I,g,function(t){return n[t]}.bind(null,g));return I},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},e.p="",e(e.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /Users/iago/Workspace/falcon-benchmark/node_modules/mitt/dist/mitt.es.js\n//      \n// An event handler can take an optional event argument\n// and should not return a value\n                                          \n                                                               \n\n// An array of all currently registered event handlers for a type\n                                            \n                                                            \n// A map of event types and their corresponding event handlers.\n                        \n                                 \n                                   \n  \n\n/** Mitt: Tiny (~200b) functional event emitter / pubsub.\n *  @name mitt\n *  @returns {Mitt}\n */\nfunction mitt(all                 ) {\n\tall = all || Object.create(null);\n\n\treturn {\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to listen for, or `"*"` for all events\n\t\t * @param  {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton: function on(type        , handler              ) {\n\t\t\t(all[type] || (all[type] = [])).push(handler);\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to unregister `handler` from, or `"*"`\n\t\t * @param  {Function} handler Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff: function off(type        , handler              ) {\n\t\t\tif (all[type]) {\n\t\t\t\tall[type].splice(all[type].indexOf(handler) >>> 0, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `"*"` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * @param {String} type  The event type to invoke\n\t\t * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit: function emit(type        , evt     ) {\n\t\t\t(all[type] || []).slice().map(function (handler) { handler(evt); });\n\t\t\t(all[\'*\'] || []).slice().map(function (handler) { handler(type, evt); });\n\t\t}\n\t};\n}\n\n/* harmony default export */ var mitt_es = (mitt);\n//# sourceMappingURL=mitt.es.js.map\n\n// CONCATENATED MODULE: ./lib/index.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on", function() { return on; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "off", function() { return off; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNumberOfTests", function() { return getNumberOfTests; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "benchmark", function() { return benchmark; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xbenchmark", function() { return xbenchmark; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "run", function() { return run; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runBenchmark", function() { return runBenchmark; });\n\n\nconst EVENTS = {\n    TEST_COMPLETE: \'test-complete\',\n    SUITE_COMPLETE: \'suite-complete\'\n}\nconst emitter = mitt_es();\nconst tests = [];\n\n/**\n * \n * @param {string} event \n * @param {function} callback \n */\nfunction on(event, callback) {\n    return emitter.on(event, callback);\n}\n\n/**\n * \n * @param {string} event \n * @param {function} callback \n */\nfunction off(event, callback) {\n    return emitter.off(event, callback);\n}\n\n/**\n * Get the count of tests in the suite\n */\nfunction getNumberOfTests() {\n    return tests.length;\n}\n\n/**\n * Add a test to the test list.\n * \n * @param {string} name - Name of the benchmark\n * @param {function} fn - Function to benchmark\n * @param {object} options \n * @param {number} options.runs - Number of cycles to execute the funcion \n */\nfunction benchmark(name, fn, options = {}) {\n    tests.push({ name, fn, options, skipped: false });\n}\n\n/**\n * Add a test that wont be executed to the test list\n */\nfunction xbenchmark(name, fn, options = {}) {\n    tests.push({ name, fn, options, skipped: true });\n}\n\n/**\n * Run all the specs\n */\nfunction run() {\n    const results = [];\n    while (tests.length) {\n        const test = tests.shift();\n        const result = test.skipped ? {} : runBenchmark(test.name, test.fn, test.options);\n        emitter.emit(EVENTS.TEST_COMPLETE, { test, result });\n        results.push({ test, result });\n    }\n    emitter.emit(EVENTS.SUITE_COMPLETE, results);\n}\n\n/**\n * Compute stats about the given function.\n * \n * @param {string} name - Name of the benchmark\n * @param {function} fn - Function to benchmark\n * @param {object} options \n * @param {number} options.runs - Number of cycles to execute the funcion \n */\nfunction runBenchmark(name, fn, options = {}) {\n    const { runs = 5e4 } = options;\n    const executions = [];\n    // First run to determine which function use\n    const profileFn = _profile(fn) === 0 ? _profileAvg : _profile;\n\n    for (let i = 0; i < runs; i++) {\n        const time = profileFn(fn);\n        executions.push(time);\n    }\n\n    const result = _getStats(executions);\n    result.meta = { uns: runs, aprox: (profileFn === _profileAvg) };\n    return result;\n}\n\n/**\n * Computes the time needed to run the function\n * @param {function} fn \n */\nfunction _profile(fn) {\n    const start = performance.now();\n    fn();\n    const end = performance.now();\n    return end - start;\n}\n\n/**\n * Computes the time needed to run the function as the avg time of 1000 runs.\n * This function is used when fn takes a small amout of time to be executed\n * @param {function} fn \n */\nfunction _profileAvg(fn) {\n    const start = performance.now();\n    for (let i = 0; i < 1000; i++) {\n        fn();\n    }\n    const end = performance.now();\n    return (end - start) / 1000;\n}\n\n/**\n * Computes statistical parameters from a time array.\n * @param {Array<number>} execution \n */\nfunction _getStats(execution = []) {\n    const total = _sum(execution);\n    const avg = _mean(execution);\n    const variance = _variance(execution, avg);\n    const min = _min(execution);\n    const max = _max(execution);\n    const median = execution.sort()[Math.floor(execution.length / 2)];\n\n    return { avg, median, max, min, variance }\n}\n\nfunction _max(array) {\n    return array.reduce((p, n) => p > n ? p : n, Number.NEGATIVE_INFINITY)\n}\n\nfunction _min(array) {\n    return array.reduce((p, n) => p < n ? p : n, Number.POSITIVE_INFINITY)\n}\n\nfunction _variance(array, mean = _mean(array)) {\n    return _mean(array.map(e => Math.pow(e - mean, 2)));\n}\n\nfunction _sum(array) {\n    return array.reduce((p, n) => p + n, 0);\n}\n\nfunction _mean(array) {\n    const sum = _sum(array);\n    return sum / array.length;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYWxjb24vL1VzZXJzL2lhZ28vV29ya3NwYWNlL2ZhbGNvbi1iZW5jaG1hcmsvbm9kZV9tb2R1bGVzL21pdHQvZGlzdC9taXR0LmVzLmpzPzFkN2EiLCJ3ZWJwYWNrOi8vZmFsY29uLy4vbGliL2luZGV4LmpzPzliMGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBOzs7O0FBSUE7OztBQUdBOzs7Ozs7QUFNQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWMsRUFBRTtBQUNyRSxvREFBb0Qsb0JBQW9CLEVBQUU7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7QUMvREE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSx5Q0FBZ0Q7QUFDaEQsZ0JBQWdCLG9DQUFvQztBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBaUQ7QUFDakQsZ0JBQWdCLG1DQUFtQztBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyw0Q0FBNEMsZUFBZTtBQUMzRCxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsNENBQW1EO0FBQ25ELFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgICBcbi8vIEFuIGV2ZW50IGhhbmRsZXIgY2FuIHRha2UgYW4gb3B0aW9uYWwgZXZlbnQgYXJndW1lbnRcbi8vIGFuZCBzaG91bGQgbm90IHJldHVybiBhIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4vLyBBbiBhcnJheSBvZiBhbGwgY3VycmVudGx5IHJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlcnMgZm9yIGEgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuLy8gQSBtYXAgb2YgZXZlbnQgdHlwZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgZXZlbnQgaGFuZGxlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgXG5cbi8qKiBNaXR0OiBUaW55ICh+MjAwYikgZnVuY3Rpb25hbCBldmVudCBlbWl0dGVyIC8gcHVic3ViLlxuICogIEBuYW1lIG1pdHRcbiAqICBAcmV0dXJucyB7TWl0dH1cbiAqL1xuZnVuY3Rpb24gbWl0dChhbGwgICAgICAgICAgICAgICAgICkge1xuXHRhbGwgPSBhbGwgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBnaXZlbiB0eXBlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXHRUeXBlIG9mIGV2ZW50IHRvIGxpc3RlbiBmb3IsIG9yIGBcIipcImAgZm9yIGFsbCBldmVudHNcblx0XHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gaGFuZGxlciBGdW5jdGlvbiB0byBjYWxsIGluIHJlc3BvbnNlIHRvIGdpdmVuIGV2ZW50XG5cdFx0ICogQG1lbWJlck9mIG1pdHRcblx0XHQgKi9cblx0XHRvbjogZnVuY3Rpb24gb24odHlwZSAgICAgICAgLCBoYW5kbGVyICAgICAgICAgICAgICApIHtcblx0XHRcdChhbGxbdHlwZV0gfHwgKGFsbFt0eXBlXSA9IFtdKSkucHVzaChoYW5kbGVyKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBnaXZlbiB0eXBlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXHRUeXBlIG9mIGV2ZW50IHRvIHVucmVnaXN0ZXIgYGhhbmRsZXJgIGZyb20sIG9yIGBcIipcImBcblx0XHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gaGFuZGxlciBIYW5kbGVyIGZ1bmN0aW9uIHRvIHJlbW92ZVxuXHRcdCAqIEBtZW1iZXJPZiBtaXR0XG5cdFx0ICovXG5cdFx0b2ZmOiBmdW5jdGlvbiBvZmYodHlwZSAgICAgICAgLCBoYW5kbGVyICAgICAgICAgICAgICApIHtcblx0XHRcdGlmIChhbGxbdHlwZV0pIHtcblx0XHRcdFx0YWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEludm9rZSBhbGwgaGFuZGxlcnMgZm9yIHRoZSBnaXZlbiB0eXBlLlxuXHRcdCAqIElmIHByZXNlbnQsIGBcIipcImAgaGFuZGxlcnMgYXJlIGludm9rZWQgYWZ0ZXIgdHlwZS1tYXRjaGVkIGhhbmRsZXJzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgIFRoZSBldmVudCB0eXBlIHRvIGludm9rZVxuXHRcdCAqIEBwYXJhbSB7QW55fSBbZXZ0XSAgQW55IHZhbHVlIChvYmplY3QgaXMgcmVjb21tZW5kZWQgYW5kIHBvd2VyZnVsKSwgcGFzc2VkIHRvIGVhY2ggaGFuZGxlclxuXHRcdCAqIEBtZW1iZXJPZiBtaXR0XG5cdFx0ICovXG5cdFx0ZW1pdDogZnVuY3Rpb24gZW1pdCh0eXBlICAgICAgICAsIGV2dCAgICAgKSB7XG5cdFx0XHQoYWxsW3R5cGVdIHx8IFtdKS5zbGljZSgpLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyBoYW5kbGVyKGV2dCk7IH0pO1xuXHRcdFx0KGFsbFsnKiddIHx8IFtdKS5zbGljZSgpLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyBoYW5kbGVyKHR5cGUsIGV2dCk7IH0pO1xuXHRcdH1cblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWl0dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pdHQuZXMuanMubWFwXG4iLCJpbXBvcnQgbWl0dCBmcm9tICdtaXR0J1xuXG5jb25zdCBFVkVOVFMgPSB7XG4gICAgVEVTVF9DT01QTEVURTogJ3Rlc3QtY29tcGxldGUnLFxuICAgIFNVSVRFX0NPTVBMRVRFOiAnc3VpdGUtY29tcGxldGUnXG59XG5jb25zdCBlbWl0dGVyID0gbWl0dCgpO1xuY29uc3QgdGVzdHMgPSBbXTtcblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFxuICovXG5leHBvcnQgZnVuY3Rpb24gb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIub24oZXZlbnQsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZmKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBlbWl0dGVyLm9mZihldmVudCwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY291bnQgb2YgdGVzdHMgaW4gdGhlIHN1aXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXJPZlRlc3RzKCkge1xuICAgIHJldHVybiB0ZXN0cy5sZW5ndGg7XG59XG5cbi8qKlxuICogQWRkIGEgdGVzdCB0byB0aGUgdGVzdCBsaXN0LlxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGJlbmNobWFya1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBGdW5jdGlvbiB0byBiZW5jaG1hcmtcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucnVucyAtIE51bWJlciBvZiBjeWNsZXMgdG8gZXhlY3V0ZSB0aGUgZnVuY2lvbiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlbmNobWFyayhuYW1lLCBmbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGVzdHMucHVzaCh7IG5hbWUsIGZuLCBvcHRpb25zLCBza2lwcGVkOiBmYWxzZSB9KTtcbn1cblxuLyoqXG4gKiBBZGQgYSB0ZXN0IHRoYXQgd29udCBiZSBleGVjdXRlZCB0byB0aGUgdGVzdCBsaXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4YmVuY2htYXJrKG5hbWUsIGZuLCBvcHRpb25zID0ge30pIHtcbiAgICB0ZXN0cy5wdXNoKHsgbmFtZSwgZm4sIG9wdGlvbnMsIHNraXBwZWQ6IHRydWUgfSk7XG59XG5cbi8qKlxuICogUnVuIGFsbCB0aGUgc3BlY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgd2hpbGUgKHRlc3RzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB0ZXN0ID0gdGVzdHMuc2hpZnQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGVzdC5za2lwcGVkID8ge30gOiBydW5CZW5jaG1hcmsodGVzdC5uYW1lLCB0ZXN0LmZuLCB0ZXN0Lm9wdGlvbnMpO1xuICAgICAgICBlbWl0dGVyLmVtaXQoRVZFTlRTLlRFU1RfQ09NUExFVEUsIHsgdGVzdCwgcmVzdWx0IH0pO1xuICAgICAgICByZXN1bHRzLnB1c2goeyB0ZXN0LCByZXN1bHQgfSk7XG4gICAgfVxuICAgIGVtaXR0ZXIuZW1pdChFVkVOVFMuU1VJVEVfQ09NUExFVEUsIHJlc3VsdHMpO1xufVxuXG4vKipcbiAqIENvbXB1dGUgc3RhdHMgYWJvdXQgdGhlIGdpdmVuIGZ1bmN0aW9uLlxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGJlbmNobWFya1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBGdW5jdGlvbiB0byBiZW5jaG1hcmtcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucnVucyAtIE51bWJlciBvZiBjeWNsZXMgdG8gZXhlY3V0ZSB0aGUgZnVuY2lvbiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bkJlbmNobWFyayhuYW1lLCBmbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBydW5zID0gNWU0IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGV4ZWN1dGlvbnMgPSBbXTtcbiAgICAvLyBGaXJzdCBydW4gdG8gZGV0ZXJtaW5lIHdoaWNoIGZ1bmN0aW9uIHVzZVxuICAgIGNvbnN0IHByb2ZpbGVGbiA9IF9wcm9maWxlKGZuKSA9PT0gMCA/IF9wcm9maWxlQXZnIDogX3Byb2ZpbGU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bnM7IGkrKykge1xuICAgICAgICBjb25zdCB0aW1lID0gcHJvZmlsZUZuKGZuKTtcbiAgICAgICAgZXhlY3V0aW9ucy5wdXNoKHRpbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IF9nZXRTdGF0cyhleGVjdXRpb25zKTtcbiAgICByZXN1bHQubWV0YSA9IHsgdW5zOiBydW5zLCBhcHJveDogKHByb2ZpbGVGbiA9PT0gX3Byb2ZpbGVBdmcpIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgdGltZSBuZWVkZWQgdG8gcnVuIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gXG4gKi9cbmZ1bmN0aW9uIF9wcm9maWxlKGZuKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBmbigpO1xuICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHJldHVybiBlbmQgLSBzdGFydDtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgdGltZSBuZWVkZWQgdG8gcnVuIHRoZSBmdW5jdGlvbiBhcyB0aGUgYXZnIHRpbWUgb2YgMTAwMCBydW5zLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHdoZW4gZm4gdGFrZXMgYSBzbWFsbCBhbW91dCBvZiB0aW1lIHRvIGJlIGV4ZWN1dGVkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBcbiAqL1xuZnVuY3Rpb24gX3Byb2ZpbGVBdmcoZm4pIHtcbiAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAgIGZuKCk7XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMTAwMDtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBzdGF0aXN0aWNhbCBwYXJhbWV0ZXJzIGZyb20gYSB0aW1lIGFycmF5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBleGVjdXRpb24gXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdGF0cyhleGVjdXRpb24gPSBbXSkge1xuICAgIGNvbnN0IHRvdGFsID0gX3N1bShleGVjdXRpb24pO1xuICAgIGNvbnN0IGF2ZyA9IF9tZWFuKGV4ZWN1dGlvbik7XG4gICAgY29uc3QgdmFyaWFuY2UgPSBfdmFyaWFuY2UoZXhlY3V0aW9uLCBhdmcpO1xuICAgIGNvbnN0IG1pbiA9IF9taW4oZXhlY3V0aW9uKTtcbiAgICBjb25zdCBtYXggPSBfbWF4KGV4ZWN1dGlvbik7XG4gICAgY29uc3QgbWVkaWFuID0gZXhlY3V0aW9uLnNvcnQoKVtNYXRoLmZsb29yKGV4ZWN1dGlvbi5sZW5ndGggLyAyKV07XG5cbiAgICByZXR1cm4geyBhdmcsIG1lZGlhbiwgbWF4LCBtaW4sIHZhcmlhbmNlIH1cbn1cblxuZnVuY3Rpb24gX21heChhcnJheSkge1xuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoKHAsIG4pID0+IHAgPiBuID8gcCA6IG4sIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSlcbn1cblxuZnVuY3Rpb24gX21pbihhcnJheSkge1xuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoKHAsIG4pID0+IHAgPCBuID8gcCA6IG4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbn1cblxuZnVuY3Rpb24gX3ZhcmlhbmNlKGFycmF5LCBtZWFuID0gX21lYW4oYXJyYXkpKSB7XG4gICAgcmV0dXJuIF9tZWFuKGFycmF5Lm1hcChlID0+IE1hdGgucG93KGUgLSBtZWFuLCAyKSkpO1xufVxuXG5mdW5jdGlvbiBfc3VtKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgocCwgbikgPT4gcCArIG4sIDApO1xufVxuXG5mdW5jdGlvbiBfbWVhbihhcnJheSkge1xuICAgIGNvbnN0IHN1bSA9IF9zdW0oYXJyYXkpO1xuICAgIHJldHVybiBzdW0gLyBhcnJheS5sZW5ndGg7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')}])});